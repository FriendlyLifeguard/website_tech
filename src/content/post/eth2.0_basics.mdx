---
title: "A Gentle Introduction to Beacon Chain"
description: "Key concepts in beacon chain"
publishDate: "2025-02-13"
tags: ["ethereum", "consensus"]
draft: false
---


The Merge event happened on September 15, 2022. This was a pivotal moment for Ethereum as it transitioned from Proof of Work (PoW) to Proof of Stake (PoS) consensus. The new consensus introduced a lot of changes including new roles for network participants, new ways of propagating/finalizing blocks and the idea of slashing. This article contains collection of different concepts that are important to understand the beacon chain. 

Let's dive in!

## Major Improvements From PoW  

Under PoW consensus, network participants were known as *miners* that raced to generate a unique hash under network's <a href="https://learnmeabitcoin.com/beginners/guide/difficulty/#:~:text=The%20difficulty%20is%20a%20number,new%20blocks%20to%20the%20blockchain."   target="_blank">difficulty value.</a> Once the miner brute forces the right hash, the miner earns the opportunity to propose a block and earns a block reward if the block gets accepted. Under the PoW consensus, a block is generated every ~10 minutes and the difficulty level increases or decreases to meet this criteria. 

Over the years, the number of miners and its respective hash rate have steadily <a href="https://www.blockchain.com/explorer/charts/hash-rate" target="_blank">increased</a> which meant that the difficulty level also increased. This lead to a higher competition for miners as they have to generate even more hashes per second to earn the right to propose a block. Generating more hashes meant that miners have to add more ASICs or GPUs which lead to an increase in energy consumption to power and maintain the machines.

However, under PoS consensus, network participants have transitioned from actively generating trillions of hashes to attesting and proposing new blocks all under algorithmic control. These participants are called *validators*. This transition from PoW to PoS lead to reduction in energy consumption by <a href="https://ethereum.org/en/roadmap/merge/" target="_blank">99.5%.</a>

## Introduction to Validators

In Beacon Chain, a validator is a new role that didn't exist previously in PoW consensus. To be able to become a validator, you need to deposit/stake 32 ETH into a Beacon Chain client. (<a href="https://launchpad.ethereum.org/en/" target="_blank">Guide</a> to get started on becoming a validator.)

On Beacon Chain, passage of time is organized into *slots* and *epochs*. A slot appears every 12 seconds and an epoch contains 32 slots (appears every 6.4 minutes) and it is used to create checkpoints to reach block/transaction <a href="https://ethereum.org/en/roadmap/single-slot-finality/#what-is-finality:~:text=In%20Ethereum%27s%20proof,from%20trying%20it." target="_blank">finality</a> which will get into it in later sections.

![slot_epoch](../image/eth2.0_basics/epoch_slots.png)

From the active pool of validators, a subset of validators can become either part of a committee or a block proposer or both! The selection processes are pseudorandom and determined by RANDAO.

1. If a validator becomes a block proposer, the validator can propose a new block on the designated slot however, an empty slot can exist if the block proposer is inactive. (The validator is not penalized for not proposing a block but it will miss out on the rewards.)

2. If a validator becomes part of a committee, each committee is delegated to a slot within an epoch to attest on the proposed block. 
- *A validator can only be part of one committee per epoch.*
- *More than one committee can exist in each slot.*
- *All committees are the same size and have at least 128 validators.*

![randao](../image/eth2.0_basics/randao.png)

The assignment of committees happens before a new epoch starts while block proposers are assigned once the epoch starts. 

Next, we will dive into the role of RANDAO which is used to select block proposers and committees.

## Achieving Decentralized Pseudorandomness with RANDAO

On Beacon Chain, the role of RANDAO value is critical as it is used to determine the selection of committees and block proposers for each upcoming epochs.

The RANDAO value goes through a series of *reveal* and *mix* process for each slot by the block proposer.  
- A block proposer is revealing and mixing their RANDAO value while also proposing a block.
- If a block proposer does not propose a block, it also does not contribute to the RANDAO value.

Revealing is simply the block proposer crafting a new RANDAO value in the proposed slot

- <a href="https://github.com/ethereum/consensus-specs/blob/7480d0334fd81cd029bc85b38c5c7bdc2967acbf/specs/phase0/validator.md?plain=1#L324-L329" target="_blank">Revealing</a>: Revealing is a process of using a BLS signature scheme to create a signature in the current slot. The signature takes in message (current epoch number) and the block proposer's secret key. The resulting signature is our RANDAO value. The last block proposer in each epoch finalizes the RANDAO value that will be used to elect block proposers and committees for the next epoch.


```python
def get_epoch_signature(state: BeaconState, block: BeaconBlock, privkey: int) -> BLSSignature:
    domain = get_domain(state, DOMAIN_RANDAO, compute_epoch_at_slot(block.slot))
    signing_root = compute_signing_root(compute_epoch_at_slot(block.slot), domain)
    return bls.Sign(privkey, signing_root)
```

<br/>

Mixing is the process of combining the current slot's RANDAO value with the previous mixed RANDAO value. Each block proposer collectively contributes to shuffling the RANDAO value which leads to a fair, decentralized way of electing block proposers and commitees on the next epoch.  

- <a href="https://github.com/ethereum/consensus-specs/blob/9d1e7087b3d0e5d3861b67dcf932158e26332fe3/specs/phase0/beacon-chain.md?plain=1#L1729-L1741">Mixing </a>: Before mixing, we first verify whether the signature was actually created by the validator. This is possible by taking block proposer's public key, message and signature. If the signature is valid, we do xor operation between the current revealed RANDAO value with the previous mixed RANDAO value.

```python
def process_randao(state: BeaconState, body: BeaconBlockBody) -> None:
    epoch = get_current_epoch(state)
    # Verify RANDAO reveal
    proposer = state.validators[get_beacon_proposer_index(state)]
    signing_root = compute_signing_root(epoch, get_domain(state, DOMAIN_RANDAO))
    assert bls.Verify(proposer.pubkey, signing_root, body.randao_reveal)
    # Mix in RANDAO reveal
    mix = xor(get_randao_mix(state, epoch), hash(body.randao_reveal))
    state.randao_mixes[epoch % EPOCHS_PER_HISTORICAL_VECTOR] = mix
```

<br/>

So to summarize, from slot 0 to 31, each block proposer reveals a RANDAO value while proposing a block. Once the block is processed, the previous mixed RANDAO value is fetched and it does xor operation with the current revealed RANDAO value. The RANDAO value in the last slot (slot 31) or the most recent slot with proposed block in the current epoch is used to select the block proposer and committees for the next epoch. 

![randao_explanation](../image/eth2.0_basics/randao_explanation.svg)

Thus, the process of each block proposer revealing and mixing RANDAO value achieves decentralized pseudorandomness with high entropy (256 bit from secret key). 

As always, the RANDAO process is not always perfect. We will look into a particular change that RANDAO underwent to improve the process.

_To learn more about RANDAO and its intricacies, please refer to the <a href="https://eth2book.info/capella/part2/building_blocks/randomness/" target="_blank">in-depth explanation</a> written by Ben Edgington._

### RANDAO Limitation and Mitigation

Let's look at a situation where Bob controls two validators that were chosen to be last two block proposers in an epoch (slot 30 and 31). Bob wants to precompute the best RANDAO value to his favor. 

Bob can precompute the best RANDAO value by: 

1. Proposing a block in both slot 30 and 31.
2. Proposing a block in slot 30 and not in slot 31 (Missing out reward in slot 31).
3. Proposing a block in slot 31 and not in slot 30 (Missing out reward in slot 30).
4. Not proposing a block in either slot 30 or 31 (Missing out reward in both slots).

*Note: Not proposing a block means that the RANDAO value remains unchanged.*

We can see that Bob has full control of what he can do with the two validators. He can strategically choose to propose or not propose blocks. He also has the option to precompute by changing the order of his validators.

Given this situation, in the previous iteration of the `process_randao` function, Bob would have maximum grinding opportunity that allowed him to generate new RANDAO values by changing the order of his validators. However, the function was improved by replacing hash with xor operation. XOR operation naturally carries commutative property which meant that the RANDAO value would be the <a href="https://notes.ethereum.org/@JustinDrake/rkPjB1_xr#:~:text=XORing%20vs%20hash,formal%20lower%20bounds." target="_blank">same</a> regardless of the order of the validators.

The change happened in the following <a href="https://github.com/ethereum/consensus-specs/pull/496" target="_blank">discussion</a> that ultimately lead to reverting back to the xor operation instead of hash. 

The specific commit <a href="https://github.com/ethereum/consensus-specs/pull/498/commits/438c013a8ca78095c690866bad23bfb7c6e97bbb" target="_blank">commit</a> shows the change.

![randao_xor_change](../image/eth2.0_basics/randao_change.png)

We can see from the last two lines that the mix operation uses xor operation on previous mixed RANDAO value and the current revealed RANDAO value. (We still utilize hash operation to reduce the size of the <a href="https://eth2book.info/capella/part2/building_blocks/randomness/#updating-the-randao:~:text=Second%2C%20the%20hash,of%20BLS%20signatures" target="_blank">revealed RANDAO value</a> from 768 bits to 256 bits.) The change has greatly reduced the randomness that Bob could've taken advantage of to precompute new RANDAO values that can favor his validators on next epoch. 

## Supermajority

The head of beacon chain is determined by reaching supermajority where $$ 2/3 $$ of the total validator's <a href="https://eth2book.info/capella/part2/incentives/balances/#li_2" target="_blank">effective balance</a> has attested to a particular checkpoint. This can also mean that if the attacker can control 33% of the staked Ether, it can disturb the finality of the beacon chain. 

## Attesting and Reaching Finality

Validators attest to a proposed block but they also attest on checkpoints. *Checkpoints*,  the first proposed block in each starting epoch, act as the anchor for the current head of the chain. If a checkpoint reaches supermajority, all the proposed blocks in the previous epoch and the block contained in the slot where the checkpoint attestation was held also becomes valid. In a case where if a validator does not detect any checkpoint block in upcoming epochs, it will refer to last known epoch's checkpoint (first proposed block of that epoch) as the current head of the chain.

- If the current epoch's checkpoint passes, the previous checkpoint becomes *justified*.
 This is basically being in a pending state and it is waiting for the next checkpoint to be passed. Once the upcoming checkpoint passes, the previous epoch's checkpoint becomes *finalized* and the slot up to where the previous checkpoint attestation occurred is considered valid and reaches finality. 
- It is possible that multiple epochs can refer to the same checkpoint as checkpoints in those epochs are still in justified state. 
- A checkpoint is either the proposed block in the first slot on each epoch or the most recently proposed block.
- There always exists a checkpoint in each epoch.
- A checkpoint accounts for the blocks in the previous epoch which means that the checkpoint that exists in the second epoch accounts for the blocks included in the first epoch. 

The attestation to vote on a checkpoint is called a *FFG Vote* and the attestation is done by every validator. 

A GHOST vote is done by individual validators to attest a proposed block in their designated slots. 


This leads to two types of attestations:

1. Attesting on individual block within a slot to determine the head of the chain (LMD Ghost Vote).
2. Attesting on a checkpoint to reach finality of a epoch (FFG Vote).

## Brief Introduction to Slashing

It is vital that validators attest to the right blocks and checkpoints to reach finality. To enforce that finality is always truthful, those that attest to blocks that have reached supermajority are rewarded while those attest to untruthful blocks are punished. A truthful validator can also report a malicious validator by reading on-chain events and this is known as a <a href="https://eth2book.info/capella/part2/incentives/slashing/#the-whistleblower-reward" target="_blank">whistleblower reward</a>.

A malicious validator will be slashed from their total stake thus decreasing their effective balance. Lower effective balance can lead to less influence during attestations and less chance to be selected as a block proposer.

List of events that are subjected to slashing can include:

1. Attesting to a block that is not finalized later. 
2. Not attesting to a block in an assigned slot (inactivity). 
3. Double proposal: proposing more than one block in a slot.


## Final Thoughts

In this article, we discussed some of the major concepts in beacon chain and how it is more energy efficient than PoW. In particular, we took a peak at the RANDAO process and BLS signature scheme that is used to compute and mix RANDAO values. Lastly, we briefly went over how beacon chain reaches finality through checkpoints and different ways validators can be slashed. 
